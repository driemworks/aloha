"use strict";
// inspired by:
// https://github.com/angular/angular-cli/blob/d202480a1707be6575b2c8cf0383cfe6db44413c/packages/schematics/angular/utility/ast-utils.ts
// https://github.com/angular/angular-cli/blob/d202480a1707be6575b2c8cf0383cfe6db44413c/packages/schematics/angular/utility/ng-ast-utils.ts
// https://github.com/NativeScript/nativescript-schematics/blob/438b9e3ef613389980bfa9d071e28ca1f32ab04f/src/ast-utils.ts
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const ts = require("typescript");
const transformers_1 = require("@ngtools/webpack/src/transformers");
const ast_utils_1 = require("../utils/ast-utils");
const transformers_utils_1 = require("../utils/transformers-utils");
function nsReplaceLazyLoader(getNgCompiler) {
    const getTypeChecker = () => getNgCompiler().typeChecker;
    const standardTransform = function (sourceFile) {
        let ops = [];
        const entryModule = transformers_utils_1.getResolvedEntryModule(getNgCompiler());
        const sourceFilePath = path_1.join(path_1.dirname(sourceFile.fileName), path_1.basename(sourceFile.fileName, path_1.extname(sourceFile.fileName)));
        if (!entryModule || path_1.normalize(sourceFilePath) !== path_1.normalize(entryModule.path)) {
            return ops;
        }
        try {
            ops = addArrayPropertyValueToNgModule(sourceFile, "providers", "NgModuleFactoryLoader", "{ provide: nsNgCoreImport_Generated.NgModuleFactoryLoader, useClass: NSLazyModulesLoader_Generated }") || [];
        }
        catch (e) {
            ops = [];
        }
        return ops;
    };
    return transformers_1.makeTransform(standardTransform, getTypeChecker);
}
exports.nsReplaceLazyLoader = nsReplaceLazyLoader;
function addArrayPropertyValueToNgModule(sourceFile, targetPropertyName, newPropertyValueMatch, newPropertyValue) {
    const ngModuleConfigNodesInFile = ast_utils_1.getDecoratorMetadata(sourceFile, "NgModule", "@angular/core");
    let ngModuleConfigNode = ngModuleConfigNodesInFile && ngModuleConfigNodesInFile[0];
    if (!ngModuleConfigNode) {
        return null;
    }
    const importsInFile = transformers_1.collectDeepNodes(sourceFile, ts.SyntaxKind.ImportDeclaration);
    const lastImport = importsInFile && importsInFile[importsInFile.length - 1];
    if (!lastImport) {
        return null;
    }
    const ngLazyLoaderNode = ts.createIdentifier(exports.NgLazyLoaderCode);
    if (ngModuleConfigNode.kind === ts.SyntaxKind.Identifier) {
        const ngModuleConfigIndentifierNode = ngModuleConfigNode;
        // cases like @NgModule(myCoolConfig)
        const configObjectDeclarationNodes = transformers_1.collectDeepNodes(sourceFile, ts.SyntaxKind.VariableStatement).filter(imp => {
            return ast_utils_1.findNode(imp, ts.SyntaxKind.Identifier, ngModuleConfigIndentifierNode.getText());
        });
        // will be undefined when the object is imported from another file
        const configObjectDeclaration = (configObjectDeclarationNodes && configObjectDeclarationNodes[0]);
        const configObjectName = ngModuleConfigIndentifierNode.escapedText.trim();
        const configObjectSetupCode = getConfigObjectSetupCode(configObjectName, targetPropertyName, newPropertyValueMatch, newPropertyValue);
        const configObjectSetupNode = ts.createIdentifier(configObjectSetupCode);
        return [
            new transformers_1.AddNodeOperation(sourceFile, lastImport, undefined, ngLazyLoaderNode),
            new transformers_1.AddNodeOperation(sourceFile, configObjectDeclaration || lastImport, undefined, configObjectSetupNode)
        ];
    }
    else if (ngModuleConfigNode.kind === ts.SyntaxKind.ObjectLiteralExpression) {
        // cases like @NgModule({ bootstrap: ... })
        const ngModuleConfigObjectNode = ngModuleConfigNode;
        const matchingProperties = ast_utils_1.getObjectPropertyMatches(ngModuleConfigObjectNode, sourceFile, targetPropertyName);
        if (!matchingProperties) {
            // invalid object
            return null;
        }
        if (matchingProperties.length === 0) {
            if (ngModuleConfigObjectNode.properties.length === 0) {
                // empty object @NgModule({ })
                return null;
            }
            // the target field is missing, we will insert it @NgModule({ otherProps })
            const lastConfigObjPropertyNode = ngModuleConfigObjectNode.properties[ngModuleConfigObjectNode.properties.length - 1];
            const newTargetPropertyNode = ts.createIdentifier(`${targetPropertyName}: [${newPropertyValue}]`);
            return [
                new transformers_1.AddNodeOperation(sourceFile, lastConfigObjPropertyNode, undefined, newTargetPropertyNode),
                new transformers_1.AddNodeOperation(sourceFile, lastImport, undefined, ngLazyLoaderNode)
            ];
        }
        // the target property is found
        const targetPropertyNode = matchingProperties[0];
        if (targetPropertyNode.initializer.kind !== ts.SyntaxKind.ArrayLiteralExpression) {
            // not an array
            return null;
        }
        const targetPropertyValuesNode = targetPropertyNode.initializer;
        const targetPropertyValues = targetPropertyValuesNode.elements;
        if (targetPropertyValues.length > 0) {
            // @NgModule({ targetProperty: [ someValues ] })
            const targetPropertyValuesStrings = targetPropertyValues.map(node => node.getText());
            const wholeWordPropValueRegex = new RegExp("\\b" + newPropertyValueMatch + "\\b");
            if (targetPropertyValuesStrings.some(((value) => wholeWordPropValueRegex.test(value)))) {
                // already registered
                return null;
            }
            const lastPropertyValueNode = targetPropertyValues[targetPropertyValues.length - 1];
            const newPropertyValueNode = ts.createIdentifier(`${newPropertyValue}`);
            return [
                new transformers_1.AddNodeOperation(sourceFile, lastPropertyValueNode, undefined, newPropertyValueNode),
                new transformers_1.AddNodeOperation(sourceFile, lastImport, undefined, ngLazyLoaderNode)
            ];
        }
        else {
            // empty array @NgModule({ targetProperty: [ ] })
            const newTargetPropertyValuesNode = ts.createIdentifier(`[${newPropertyValue}]`);
            return [
                new transformers_1.ReplaceNodeOperation(sourceFile, targetPropertyValuesNode, newTargetPropertyValuesNode),
                new transformers_1.AddNodeOperation(sourceFile, lastImport, undefined, ngLazyLoaderNode)
            ];
        }
    }
}
exports.addArrayPropertyValueToNgModule = addArrayPropertyValueToNgModule;
// handles cases like @NgModule(myCoolConfig) by returning a code snippet for processing
// the config object and configuring its {{targetPropertyName}} based on the specified arguments
// e.g.
// if (!myCoolConfig.providers) {
//     myCoolConfig.providers = [];
// }
// if (Array.isArray(myCoolConfig.providers)) {
//     var wholeWordPropertyRegex = new RegExp("\bNgModuleFactoryLoader\b");
//     if (!myCoolConfig.providers.some(function (property) { return wholeWordPropertyRegex.test(property); })) {
//         myCoolConfig.providers.push({ provide: nsNgCoreImport_Generated.NgModuleFactoryLoader, useClass: NSLazyModulesLoader_Generated });
//     }
// }
function getConfigObjectSetupCode(configObjectName, targetPropertyName, newPropertyValueMatch, newPropertyValue) {
    return `
if (!${configObjectName}.${targetPropertyName}) {
    ${configObjectName}.${targetPropertyName} = [];
}
if (Array.isArray(${configObjectName}.${targetPropertyName})) {
    var wholeWordPropertyRegex = new RegExp("\\b${newPropertyValueMatch}\\b");
    if (!${configObjectName}.${targetPropertyName}.some(function (property) { return wholeWordPropertyRegex.test(property); })) {
        ${configObjectName}.${targetPropertyName}.push(${newPropertyValue});
    }
}
`;
}
exports.getConfigObjectSetupCode = getConfigObjectSetupCode;
// based on: https://github.com/angular/angular/blob/4c2ce4e8ba4c5ac5ce8754d67bc6603eaad4564a/packages/core/src/linker/system_js_ng_module_factory_loader.ts
// when @angular/core is an external module, this fixes https://github.com/NativeScript/nativescript-cli/issues/4024 by including the lazy loader INSIDE the bundle allowing it to access the lazy modules
exports.NgLazyLoaderCode = `
var nsNgCoreImport_Generated = require("@angular/core");
var NSLazyModulesLoader_Generated = /** @class */ (function () {
    function NSLazyModulesLoader_Generated(_compiler, config) {
        this._compiler = _compiler;
        this._config = config || {
            factoryPathPrefix: '',
            factoryPathSuffix: '.ngfactory',
        };
    }
    NSLazyModulesLoader_Generated.prototype.load = function (path) {
        var offlineMode = this._compiler instanceof nsNgCoreImport_Generated.Compiler;
        return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);
    };
    NSLazyModulesLoader_Generated.prototype.loadAndCompile = function (path) {
        var _this = this;
        var _a = path.split('#'), module = _a[0], exportName = _a[1];
        if (exportName === undefined) {
            exportName = 'default';
        }
        return import(module)
            .then(function (module) { return module[exportName]; })
            .then(function (type) { return _this.checkNotEmpty(type, module, exportName); })
            .then(function (type) { return _this._compiler.compileModuleAsync(type); });
    };
    NSLazyModulesLoader_Generated.prototype.loadFactory = function (path) {
        var _this = this;
        var _a = path.split('#'), module = _a[0], exportName = _a[1];
        var factoryClassSuffix = 'NgFactory';
        if (exportName === undefined) {
            exportName = 'default';
            factoryClassSuffix = '';
        }
        return import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)
            .then(function (module) { return module[exportName + factoryClassSuffix]; })
            .then(function (factory) { return _this.checkNotEmpty(factory, module, exportName); });
    };
    NSLazyModulesLoader_Generated.prototype.checkNotEmpty = function (value, modulePath, exportName) {
        if (!value) {
            throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
        }
        return value;
    };
    NSLazyModulesLoader_Generated = __decorate([
        nsNgCoreImport_Generated.Injectable(),
        __param(1, nsNgCoreImport_Generated.Optional()),
        __metadata("design:paramtypes", [nsNgCoreImport_Generated.Compiler, nsNgCoreImport_Generated.SystemJsNgModuleLoaderConfig])
    ], NSLazyModulesLoader_Generated);
    return NSLazyModulesLoader_Generated;
}());
`;
//# sourceMappingURL=ns-replace-lazy-loader.js.map