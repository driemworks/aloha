{"version":3,"file":"effects.umd.js","sources":["../../../../../modules/effects/src/effects_metadata.ts","../../../../../modules/effects/src/effects_resolver.ts","../../../../../modules/effects/src/actions.ts","../../../../../modules/effects/src/effect_notification.ts","../../../../../modules/effects/src/lifecycle_hooks.ts","../../../../../modules/effects/src/effect_sources.ts","../../../../../modules/effects/src/tokens.ts","../../../../../modules/effects/src/effects_runner.ts","../../../../../modules/effects/src/effects_root_module.ts","../../../../../modules/effects/src/effects_feature_module.ts","../../../../../modules/effects/src/effects_module.ts","../../../../../modules/effects/index.ts","../../../../../modules/effects/effects.ts"],"sourcesContent":["import { compose } from '@ngrx/store';\n\nconst METADATA_KEY = '__@ngrx/effects__';\n\nexport interface EffectMetadata<T> {\n  propertyName: Extract<keyof T, string>;\n  dispatch: boolean;\n}\n\nfunction getEffectMetadataEntries<T>(sourceProto: T): Array<EffectMetadata<T>> {\n  return sourceProto.constructor.hasOwnProperty(METADATA_KEY)\n    ? (sourceProto.constructor as any)[METADATA_KEY]\n    : [];\n}\n\nfunction setEffectMetadataEntries<T>(\n  sourceProto: T,\n  entries: Array<EffectMetadata<T>>\n) {\n  const constructor = sourceProto.constructor;\n  const meta: Array<EffectMetadata<T>> = constructor.hasOwnProperty(\n    METADATA_KEY\n  )\n    ? (constructor as any)[METADATA_KEY]\n    : Object.defineProperty(constructor, METADATA_KEY, { value: [] })[\n        METADATA_KEY\n      ];\n  Array.prototype.push.apply(meta, entries);\n}\n\nexport function Effect<T>({ dispatch = true } = {}): PropertyDecorator {\n  return function<K extends Extract<keyof T, string>>(\n    target: T,\n    propertyName: K\n  ) {\n    const metadata: EffectMetadata<T> = { propertyName, dispatch };\n    setEffectMetadataEntries<T>(target, [metadata]);\n  } as (target: {}, propertyName: string | symbol) => void;\n}\n\nexport function getSourceForInstance<T>(instance: T): T {\n  return Object.getPrototypeOf(instance);\n}\n\nexport function getSourceMetadata<T>(instance: T): Array<EffectMetadata<T>> {\n  return compose(\n    getEffectMetadataEntries,\n    getSourceForInstance\n  )(instance);\n}\n\nexport type EffectsMetadata<T> = {\n  [key in Extract<keyof T, string>]?: { dispatch: boolean }\n};\n\nexport function getEffectsMetadata<T>(instance: T): EffectsMetadata<T> {\n  const metadata: EffectsMetadata<T> = {};\n\n  for (const { propertyName, dispatch } of getSourceMetadata(instance)) {\n    metadata[propertyName] = { dispatch };\n  }\n\n  return metadata;\n}\n","import { Action } from '@ngrx/store';\nimport { merge, Notification, Observable } from 'rxjs';\nimport { ignoreElements, map, materialize } from 'rxjs/operators';\n\nimport { EffectNotification } from './effect_notification';\nimport { getSourceForInstance, getSourceMetadata } from './effects_metadata';\n\nexport function mergeEffects(\n  sourceInstance: any\n): Observable<EffectNotification> {\n  const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n\n  const observables: Observable<any>[] = getSourceMetadata(sourceInstance).map(\n    ({ propertyName, dispatch }): Observable<EffectNotification> => {\n      const observable: Observable<any> =\n        typeof sourceInstance[propertyName] === 'function'\n          ? sourceInstance[propertyName]()\n          : sourceInstance[propertyName];\n\n      if (dispatch === false) {\n        return observable.pipe(ignoreElements());\n      }\n\n      const materialized$ = observable.pipe(materialize());\n\n      return materialized$.pipe(\n        map(\n          (notification: Notification<Action>): EffectNotification => ({\n            effect: sourceInstance[propertyName],\n            notification,\n            propertyName,\n            sourceName,\n            sourceInstance,\n          })\n        )\n      );\n    }\n  );\n\n  return merge(...observables);\n}\n","import { Inject, Injectable } from '@angular/core';\nimport { Action, ScannedActionsSubject } from '@ngrx/store';\nimport { Observable, OperatorFunction, Operator } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n@Injectable()\nexport class Actions<V = Action> extends Observable<V> {\n  constructor(@Inject(ScannedActionsSubject) source?: Observable<V>) {\n    super();\n\n    if (source) {\n      this.source = source;\n    }\n  }\n\n  lift<R>(operator: Operator<V, R>): Observable<R> {\n    const observable = new Actions<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n}\n\n/**\n * 'ofType' filters an Observable of Actions into an observable of the actions\n * whose type strings are passed to it.\n *\n * For example, `actions.pipe(ofType('add'))` returns an\n * `Observable<AddtionAction>`\n *\n * Properly typing this function is hard and requires some advanced TS tricks\n * below.\n *\n * Type narrowing automatically works, as long as your `actions` object\n * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.\n *\n * For backwards compatibility, when one passes a single type argument\n * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`\n * completely overrides any possible inference from 'something'.\n *\n * Unfortunately, for unknown 'actions: Actions' these types will produce\n * 'Observable<never>'. In such cases one has to manually set the generic type\n * like `actions.ofType<AdditionAction>('add')`.\n */\nexport function ofType<\n  V extends Extract<U, { type: T1 }>,\n  T1 extends string = string,\n  U extends Action = Action\n>(t1: T1): OperatorFunction<U, V>;\nexport function ofType<\n  V extends Extract<U, { type: T1 | T2 }>,\n  T1 extends string = string,\n  T2 extends string = string,\n  U extends Action = Action\n>(t1: T1, t2: T2): OperatorFunction<U, V>;\nexport function ofType<\n  V extends Extract<U, { type: T1 | T2 | T3 }>,\n  T1 extends string = string,\n  T2 extends string = string,\n  T3 extends string = string,\n  U extends Action = Action\n>(t1: T1, t2: T2, t3: T3): OperatorFunction<U, V>;\nexport function ofType<\n  V extends Extract<U, { type: T1 | T2 | T3 | T4 }>,\n  T1 extends string = string,\n  T2 extends string = string,\n  T3 extends string = string,\n  T4 extends string = string,\n  U extends Action = Action\n>(t1: T1, t2: T2, t3: T3, t4: T4): OperatorFunction<U, V>;\nexport function ofType<\n  V extends Extract<U, { type: T1 | T2 | T3 | T4 | T5 }>,\n  T1 extends string = string,\n  T2 extends string = string,\n  T3 extends string = string,\n  T4 extends string = string,\n  T5 extends string = string,\n  U extends Action = Action\n>(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): OperatorFunction<U, V>;\n/**\n * Fallback for more than 5 arguments.\n * There is no inference, so the return type is the same as the input -\n * Observable<Action>.\n *\n * We provide a type parameter, even though TS will not infer it from the\n * arguments, to preserve backwards compatibility with old versions of ngrx.\n */\nexport function ofType<V extends Action>(\n  ...allowedTypes: string[]\n): OperatorFunction<Action, V>;\nexport function ofType(\n  ...allowedTypes: string[]\n): OperatorFunction<Action, Action> {\n  return filter((action: Action) =>\n    allowedTypes.some(type => type === action.type)\n  );\n}\n","import { ErrorHandler } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Notification, Observable } from 'rxjs';\n\nexport interface EffectNotification {\n  effect: Observable<any> | (() => Observable<any>);\n  propertyName: string;\n  sourceName: string;\n  sourceInstance: any;\n  notification: Notification<Action | null | undefined>;\n}\n\nexport function verifyOutput(\n  output: EffectNotification,\n  reporter: ErrorHandler\n) {\n  reportErrorThrown(output, reporter);\n  reportInvalidActions(output, reporter);\n}\n\nfunction reportErrorThrown(output: EffectNotification, reporter: ErrorHandler) {\n  if (output.notification.kind === 'E') {\n    reporter.handleError(output.notification.error);\n  }\n}\n\nfunction reportInvalidActions(\n  output: EffectNotification,\n  reporter: ErrorHandler\n) {\n  if (output.notification.kind === 'N') {\n    const action = output.notification.value;\n    const isInvalidAction = !isAction(action);\n\n    if (isInvalidAction) {\n      reporter.handleError(\n        new Error(\n          `Effect ${getEffectName(\n            output\n          )} dispatched an invalid action: ${stringify(action)}`\n        )\n      );\n    }\n  }\n}\n\nfunction isAction(action: any): action is Action {\n  return action && action.type && typeof action.type === 'string';\n}\n\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName,\n}: EffectNotification) {\n  const isMethod = typeof sourceInstance[propertyName] === 'function';\n\n  return `\"${sourceName}.${propertyName}${isMethod ? '()' : ''}\"`;\n}\n\nfunction stringify(action: Action | null | undefined) {\n  try {\n    return JSON.stringify(action);\n  } catch {\n    return action;\n  }\n}\n","import { Observable } from 'rxjs';\nimport { EffectNotification } from '.';\nimport { Action } from '@ngrx/store';\n\n/**\n * @description\n * Interface to set an identifier for effect instances.\n *\n * By default, each Effects class is registered\n * once regardless of how many times the Effect class\n * is loaded. By implementing this interface, you define\n * a unique identifier to register an Effects class instance\n * multiple times.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithIdentifier implements OnIdentifyEffects {\n * private effectIdentifier: string;\n *\n * ngrxOnIdentifyEffects() {\n *   return this.effectIdentifier;\n * }\n *\n * constructor(private effectIdentifier: string) {}\n * ```\n */\nexport interface OnIdentifyEffects {\n  /**\n   * @description\n   * String identifier to differentiate effect instances.\n   */\n  ngrxOnIdentifyEffects(): string;\n}\n\nexport const onIdentifyEffectsKey: keyof OnIdentifyEffects =\n  'ngrxOnIdentifyEffects';\n\nexport type onRunEffectsFn = (\n  resolvedEffects$: Observable<EffectNotification>\n) => Observable<EffectNotification>;\n\n/**\n * @description\n * Interface to control the lifecycle of effects.\n *\n * By default, effects are merged and subscribed to the store. Implement the OnRunEffects interface to control the lifecycle of the resolved effects.\n *\n * @usageNotes\n *\n * ### Implement the OnRunEffects interface on an Effects class\n *\n * ```ts\n * export class UserEffects implements OnRunEffects {\n *   constructor(private actions$: Actions) {}\n *\n *   ngrxOnRunEffects(resolvedEffects$: Observable<EffectNotification>) {\n *     return this.actions$.pipe(\n *       ofType('LOGGED_IN'),\n *       exhaustMap(() =>\n *         resolvedEffects$.pipe(\n *           takeUntil(this.actions$.pipe(ofType('LOGGED_OUT')))\n *         )\n *       )\n *     );\n *   }\n * }\n * ```\n */\nexport interface OnRunEffects {\n  /**\n   * @description\n   * Method to control the lifecycle of effects.\n   */\n  ngrxOnRunEffects: onRunEffectsFn;\n}\n\nexport const onRunEffectsKey: keyof OnRunEffects = 'ngrxOnRunEffects';\n\n/**\n * @description\n * Interface to dispatch an action after effect registration.\n *\n * Implement this interface to dispatch a custom action after\n * the effect has been added. You can listen to this action\n * in the rest of the application to execute something after\n * the effect is registered.\n *\n * @usageNotes\n *\n * ### Set an identifier for an Effects class\n *\n * ```ts\n * class EffectWithInitAction implements OnInitEffects {\n *\n * ngrxOnInitEffects() {\n *   return { type: '[EffectWithInitAction] Init' };\n * }\n * ```\n */\nexport interface OnInitEffects {\n  /**\n   * @description\n   * Action to be dispatched after the effect is registered.\n   */\n  ngrxOnInitEffects(): Action;\n}\n\nexport const onInitEffects: keyof OnInitEffects = 'ngrxOnInitEffects';\n","import { ErrorHandler, Injectable } from '@angular/core';\nimport { Action, Store } from '@ngrx/store';\nimport { Notification, Observable, Subject } from 'rxjs';\nimport {\n  dematerialize,\n  exhaustMap,\n  filter,\n  groupBy,\n  map,\n  mergeMap,\n} from 'rxjs/operators';\n\nimport { verifyOutput } from './effect_notification';\nimport { mergeEffects } from './effects_resolver';\nimport { getSourceForInstance } from './effects_metadata';\nimport {\n  onIdentifyEffectsKey,\n  onRunEffectsKey,\n  onRunEffectsFn,\n  OnRunEffects,\n  onInitEffects,\n} from './lifecycle_hooks';\n\n@Injectable()\nexport class EffectSources extends Subject<any> {\n  constructor(private errorHandler: ErrorHandler, private store: Store<any>) {\n    super();\n  }\n\n  addEffects(effectSourceInstance: any) {\n    this.next(effectSourceInstance);\n\n    if (\n      onInitEffects in effectSourceInstance &&\n      typeof effectSourceInstance[onInitEffects] === 'function'\n    ) {\n      this.store.dispatch(effectSourceInstance[onInitEffects]());\n    }\n  }\n\n  /**\n   * @internal\n   */\n  toActions(): Observable<Action> {\n    return this.pipe(\n      groupBy(getSourceForInstance),\n      mergeMap(source$ => source$.pipe(groupBy(effectsInstance))),\n      mergeMap(source$ =>\n        source$.pipe(\n          exhaustMap(resolveEffectSource),\n          map(output => {\n            verifyOutput(output, this.errorHandler);\n\n            return output.notification;\n          }),\n          filter(\n            (notification): notification is Notification<Action> =>\n              notification.kind === 'N'\n          ),\n          dematerialize()\n        )\n      )\n    );\n  }\n}\n\nfunction effectsInstance(sourceInstance: any) {\n  if (\n    onIdentifyEffectsKey in sourceInstance &&\n    typeof sourceInstance[onIdentifyEffectsKey] === 'function'\n  ) {\n    return sourceInstance[onIdentifyEffectsKey]();\n  }\n\n  return '';\n}\n\nfunction resolveEffectSource(sourceInstance: any) {\n  const mergedEffects$ = mergeEffects(sourceInstance);\n\n  if (isOnRunEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n  }\n\n  return mergedEffects$;\n}\n\nfunction isOnRunEffects(sourceInstance: {\n  [onRunEffectsKey]?: onRunEffectsFn;\n}): sourceInstance is OnRunEffects {\n  const source = getSourceForInstance(sourceInstance);\n\n  return (\n    onRunEffectsKey in source && typeof source[onRunEffectsKey] === 'function'\n  );\n}\n","import { InjectionToken, Type } from '@angular/core';\n\nexport const IMMEDIATE_EFFECTS = new InjectionToken<any[]>(\n  'ngrx/effects: Immediate Effects'\n);\nexport const ROOT_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Root Effects'\n);\nexport const FEATURE_EFFECTS = new InjectionToken<any[][]>(\n  'ngrx/effects: Feature Effects'\n);\n","import { Injectable, OnDestroy } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { Subscription } from 'rxjs';\n\nimport { EffectSources } from './effect_sources';\n\n@Injectable()\nexport class EffectsRunner implements OnDestroy {\n  private effectsSubscription: Subscription | null = null;\n\n  constructor(\n    private effectSources: EffectSources,\n    private store: Store<any>\n  ) {}\n\n  start() {\n    if (!this.effectsSubscription) {\n      this.effectsSubscription = this.effectSources\n        .toActions()\n        .subscribe(this.store);\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.effectsSubscription) {\n      this.effectsSubscription.unsubscribe();\n      this.effectsSubscription = null;\n    }\n  }\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport {\n  StoreModule,\n  Store,\n  StoreRootModule,\n  StoreFeatureModule,\n} from '@ngrx/store';\nimport { EffectsRunner } from './effects_runner';\nimport { EffectSources } from './effect_sources';\nimport { ROOT_EFFECTS } from './tokens';\n\nexport const ROOT_EFFECTS_INIT = '@ngrx/effects/init';\n\n@NgModule({})\nexport class EffectsRootModule {\n  constructor(\n    private sources: EffectSources,\n    runner: EffectsRunner,\n    store: Store<any>,\n    @Inject(ROOT_EFFECTS) rootEffects: any[],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule\n  ) {\n    runner.start();\n\n    rootEffects.forEach(effectSourceInstance =>\n      sources.addEffects(effectSourceInstance)\n    );\n\n    store.dispatch({ type: ROOT_EFFECTS_INIT });\n  }\n\n  addEffects(effectSourceInstance: any) {\n    this.sources.addEffects(effectSourceInstance);\n  }\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport { StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { EffectsRootModule } from './effects_root_module';\nimport { FEATURE_EFFECTS } from './tokens';\n\n@NgModule({})\nexport class EffectsFeatureModule {\n  constructor(\n    root: EffectsRootModule,\n    @Inject(FEATURE_EFFECTS) effectSourceGroups: any[][],\n    @Optional() storeRootModule: StoreRootModule,\n    @Optional() storeFeatureModule: StoreFeatureModule\n  ) {\n    effectSourceGroups.forEach(group =>\n      group.forEach(effectSourceInstance =>\n        root.addEffects(effectSourceInstance)\n      )\n    );\n  }\n}\n","import { NgModule, ModuleWithProviders, Type } from '@angular/core';\nimport { EffectSources } from './effect_sources';\nimport { Actions } from './actions';\nimport { ROOT_EFFECTS, FEATURE_EFFECTS } from './tokens';\nimport { EffectsFeatureModule } from './effects_feature_module';\nimport { EffectsRootModule } from './effects_root_module';\nimport { EffectsRunner } from './effects_runner';\n\n@NgModule({})\nexport class EffectsModule {\n  static forFeature(\n    featureEffects: Type<any>[]\n  ): ModuleWithProviders<EffectsFeatureModule> {\n    return {\n      ngModule: EffectsFeatureModule,\n      providers: [\n        featureEffects,\n        {\n          provide: FEATURE_EFFECTS,\n          multi: true,\n          deps: featureEffects,\n          useFactory: createSourceInstances,\n        },\n      ],\n    };\n  }\n\n  static forRoot(\n    rootEffects: Type<any>[]\n  ): ModuleWithProviders<EffectsRootModule> {\n    return {\n      ngModule: EffectsRootModule,\n      providers: [\n        EffectsRunner,\n        EffectSources,\n        Actions,\n        rootEffects,\n        {\n          provide: ROOT_EFFECTS,\n          deps: rootEffects,\n          useFactory: createSourceInstances,\n        },\n      ],\n    };\n  }\n}\n\nexport function createSourceInstances(...instances: any[]) {\n  return instances;\n}\n","/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\nexport * from './public_api';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n\nexport {EffectsFeatureModule as Éµngrx_modules_effects_effects_c} from './src/effects_feature_module';\nexport {createSourceInstances as Éµngrx_modules_effects_effects_a} from './src/effects_module';\nexport {EffectsRootModule as Éµngrx_modules_effects_effects_b} from './src/effects_root_module';\nexport {EffectsRunner as Éµngrx_modules_effects_effects_f} from './src/effects_runner';\nexport {FEATURE_EFFECTS as Éµngrx_modules_effects_effects_e,ROOT_EFFECTS as Éµngrx_modules_effects_effects_d} from './src/tokens';"],"names":["compose","ignoreElements","materialize","map","merge","Injectable","Inject","ScannedActionsSubject","Observable","filter","__extends","store","groupBy","mergeMap","exhaustMap","dematerialize","ErrorHandler","Store","Subject","InjectionToken","NgModule","__param","Optional","StoreRootModule","StoreFeatureModule"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,IAEA,IAAM,YAAY,GAAG,mBAAmB,CAAC;IAOzC,SAAS,wBAAwB,CAAI,WAAc;QACjD,OAAO,WAAW,CAAC,WAAW,CAAC,cAAc,CAAC,YAAY,CAAC;cACtD,WAAW,CAAC,WAAmB,CAAC,YAAY,CAAC;cAC9C,EAAE,CAAC;IACT,CAAC;IAED,SAAS,wBAAwB,CAC/B,WAAc,EACd,OAAiC;QAEjC,IAAM,WAAW,GAAG,WAAW,CAAC,WAAW,CAAC;QAC5C,IAAM,IAAI,GAA6B,WAAW,CAAC,cAAc,CAC/D,YAAY,CACb;cACI,WAAmB,CAAC,YAAY,CAAC;cAClC,MAAM,CAAC,cAAc,CAAC,WAAW,EAAE,YAAY,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,CAC7D,YAAY,CACb,CAAC;QACN,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAC5C,CAAC;AAED,aAAgB,MAAM,CAAI,EAAwB;YAAtB,uCAAe,EAAf,oCAAe;QACzC,OAAO,UACL,MAAS,EACT,YAAe;YAEf,IAAM,QAAQ,GAAsB,EAAE,YAAY,cAAA,EAAE,QAAQ,UAAA,EAAE,CAAC;YAC/D,wBAAwB,CAAI,MAAM,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;SACM,CAAC;IAC3D,CAAC;AAED,aAAgB,oBAAoB,CAAI,QAAW;QACjD,OAAO,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;IACzC,CAAC;AAED,aAAgB,iBAAiB,CAAI,QAAW;QAC9C,OAAOA,aAAO,CACZ,wBAAwB,EACxB,oBAAoB,CACrB,CAAC,QAAQ,CAAC,CAAC;IACd,CAAC;AAMD,aAAgB,kBAAkB,CAAI,QAAW;;QAC/C,IAAM,QAAQ,GAAuB,EAAE,CAAC;;YAExC,KAAyC,IAAA,KAAA,SAAA,iBAAiB,CAAC,QAAQ,CAAC,CAAA,gBAAA,4BAAE;gBAA3D,IAAA,aAA0B,EAAxB,8BAAY,EAAE,sBAAQ;gBACjC,QAAQ,CAAC,YAAY,CAAC,GAAG,EAAE,QAAQ,UAAA,EAAE,CAAC;aACvC;;;;;;;;;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;;;;;;;;;;;;;;;;;;;;;;AC9DD,aAMgB,YAAY,CAC1B,cAAmB;QAEnB,IAAM,UAAU,GAAG,oBAAoB,CAAC,cAAc,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC;QAEzE,IAAM,WAAW,GAAsB,iBAAiB,CAAC,cAAc,CAAC,CAAC,GAAG,CAC1E,UAAC,EAA0B;gBAAxB,8BAAY,EAAE,sBAAQ;YACvB,IAAM,UAAU,GACd,OAAO,cAAc,CAAC,YAAY,CAAC,KAAK,UAAU;kBAC9C,cAAc,CAAC,YAAY,CAAC,EAAE;kBAC9B,cAAc,CAAC,YAAY,CAAC,CAAC;YAEnC,IAAI,QAAQ,KAAK,KAAK,EAAE;gBACtB,OAAO,UAAU,CAAC,IAAI,CAACC,wBAAc,EAAE,CAAC,CAAC;aAC1C;YAED,IAAM,aAAa,GAAG,UAAU,CAAC,IAAI,CAACC,qBAAW,EAAE,CAAC,CAAC;YAErD,OAAO,aAAa,CAAC,IAAI,CACvBC,aAAG,CACD,UAAC,YAAkC,IAAyB,QAAC;gBAC3D,MAAM,EAAE,cAAc,CAAC,YAAY,CAAC;gBACpC,YAAY,cAAA;gBACZ,YAAY,cAAA;gBACZ,UAAU,YAAA;gBACV,cAAc,gBAAA;aACf,IAAC,CACH,CACF,CAAC;SACH,CACF,CAAC;QAEF,OAAOC,UAAK,wBAAI,WAAW,GAAE;IAC/B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxCD;QAMyC,2BAAa;QACpD,iBAA2C,MAAsB;YAAjE,YACE,iBAAO,SAKR;YAHC,IAAI,MAAM,EAAE;gBACV,KAAI,CAAC,MAAM,GAAG,MAAM,CAAC;aACtB;;SACF;oBAPU,OAAO;QASlB,sBAAI,GAAJ,UAAQ,QAAwB;YAC9B,IAAM,UAAU,GAAG,IAAI,SAAO,EAAK,CAAC;YACpC,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC;YACzB,UAAU,CAAC,QAAQ,GAAG,QAAQ,CAAC;YAC/B,OAAO,UAAU,CAAC;SACnB;;QAdU,OAAO;YADnBC,eAAU,EAAE;YAEE,WAAAC,WAAM,CAACC,2BAAqB,CAAC,CAAA;6CAAUC,eAAU;WADnD,OAAO,CAenB;QAAD,cAAC;KAAA,CAfwCA,eAAU,GAelD;aAqEe,MAAM;QACpB,sBAAyB;aAAzB,UAAyB,EAAzB,qBAAyB,EAAzB,IAAyB;YAAzB,iCAAyB;;QAEzB,OAAOC,gBAAM,CAAC,UAAC,MAAc;YAC3B,OAAA,YAAY,CAAC,IAAI,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,KAAK,MAAM,CAAC,IAAI,GAAA,CAAC;SAAA,CAChD,CAAC;IACJ,CAAC;;aCpFe,YAAY,CAC1B,MAA0B,EAC1B,QAAsB;QAEtB,iBAAiB,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;QACpC,oBAAoB,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;IACzC,CAAC;IAED,SAAS,iBAAiB,CAAC,MAA0B,EAAE,QAAsB;QAC3E,IAAI,MAAM,CAAC,YAAY,CAAC,IAAI,KAAK,GAAG,EAAE;YACpC,QAAQ,CAAC,WAAW,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;SACjD;IACH,CAAC;IAED,SAAS,oBAAoB,CAC3B,MAA0B,EAC1B,QAAsB;QAEtB,IAAI,MAAM,CAAC,YAAY,CAAC,IAAI,KAAK,GAAG,EAAE;YACpC,IAAM,MAAM,GAAG,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC;YACzC,IAAM,eAAe,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YAE1C,IAAI,eAAe,EAAE;gBACnB,QAAQ,CAAC,WAAW,CAClB,IAAI,KAAK,CACP,YAAU,aAAa,CACrB,MAAM,CACP,uCAAkC,SAAS,CAAC,MAAM,CAAG,CACvD,CACF,CAAC;aACH;SACF;IACH,CAAC;IAED,SAAS,QAAQ,CAAC,MAAW;QAC3B,OAAO,MAAM,IAAI,MAAM,CAAC,IAAI,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,QAAQ,CAAC;IAClE,CAAC;IAED,SAAS,aAAa,CAAC,EAIF;YAHnB,8BAAY,EACZ,kCAAc,EACd,0BAAU;QAEV,IAAM,QAAQ,GAAG,OAAO,cAAc,CAAC,YAAY,CAAC,KAAK,UAAU,CAAC;QAEpE,OAAO,OAAI,UAAU,SAAI,YAAY,IAAG,QAAQ,GAAG,IAAI,GAAG,EAAE,QAAG,CAAC;IAClE,CAAC;IAED,SAAS,SAAS,CAAC,MAAiC;QAClD,IAAI;YACF,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;SAC/B;QAAC,WAAM;YACN,OAAO,MAAM,CAAC;SACf;IACH,CAAC;;IC7BM,IAAM,oBAAoB,GAC/B,uBAAuB,CAAC;AAyC1B,IAAO,IAAM,eAAe,GAAuB,kBAAkB,CAAC;AA+BtE,IAAO,IAAM,aAAa,GAAwB,mBAAmB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;AC9GtE;QAwBmCC,mCAAY;QAC7C,uBAAoB,YAA0B,EAAUC,QAAiB;YAAzE,YACE,iBAAO,SACR;YAFmB,kBAAY,GAAZ,YAAY,CAAc;YAAU,WAAK,GAALA,QAAK,CAAY;;SAExE;QAED,kCAAU,GAAV,UAAW,oBAAyB;YAClC,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;YAEhC,IACE,aAAa,IAAI,oBAAoB;gBACrC,OAAO,oBAAoB,CAAC,aAAa,CAAC,KAAK,UAAU,EACzD;gBACA,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,oBAAoB,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC;aAC5D;SACF;;;;QAKD,iCAAS,GAAT;YAAA,iBAoBC;YAnBC,OAAO,IAAI,CAAC,IAAI,CACdC,iBAAO,CAAC,oBAAoB,CAAC,EAC7BC,kBAAQ,CAAC,UAAA,OAAO,IAAI,OAAA,OAAO,CAAC,IAAI,CAACD,iBAAO,CAAC,eAAe,CAAC,CAAC,GAAA,CAAC,EAC3DC,kBAAQ,CAAC,UAAA,OAAO;gBACd,OAAA,OAAO,CAAC,IAAI,CACVC,oBAAU,CAAC,mBAAmB,CAAC,EAC/BX,aAAG,CAAC,UAAA,MAAM;oBACR,YAAY,CAAC,MAAM,EAAE,KAAI,CAAC,YAAY,CAAC,CAAC;oBAExC,OAAO,MAAM,CAAC,YAAY,CAAC;iBAC5B,CAAC,EACFM,gBAAM,CACJ,UAAC,YAAY;oBACX,OAAA,YAAY,CAAC,IAAI,KAAK,GAAG;iBAAA,CAC5B,EACDM,uBAAa,EAAE,CAChB;aAAA,CACF,CACF,CAAC;SACH;QAvCU,aAAa;YADzBV,eAAU,EAAE;+CAEuBW,iBAAY,EAAiBC,WAAK;WADzD,aAAa,CAwCzB;QAAD,oBAAC;KAAA,CAxCkCC,YAAO,GAwCzC;IAED,SAAS,eAAe,CAAC,cAAmB;QAC1C,IACE,oBAAoB,IAAI,cAAc;YACtC,OAAO,cAAc,CAAC,oBAAoB,CAAC,KAAK,UAAU,EAC1D;YACA,OAAO,cAAc,CAAC,oBAAoB,CAAC,EAAE,CAAC;SAC/C;QAED,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,SAAS,mBAAmB,CAAC,cAAmB;QAC9C,IAAM,cAAc,GAAG,YAAY,CAAC,cAAc,CAAC,CAAC;QAEpD,IAAI,cAAc,CAAC,cAAc,CAAC,EAAE;YAClC,OAAO,cAAc,CAAC,gBAAgB,CAAC,cAAc,CAAC,CAAC;SACxD;QAED,OAAO,cAAc,CAAC;IACxB,CAAC;IAED,SAAS,cAAc,CAAC,cAEvB;QACC,IAAM,MAAM,GAAG,oBAAoB,CAAC,cAAc,CAAC,CAAC;QAEpD,QACE,eAAe,IAAI,MAAM,IAAI,OAAO,MAAM,CAAC,eAAe,CAAC,KAAK,UAAU,EAC1E;IACJ,CAAC;;IC7FM,IAAM,iBAAiB,GAAG,IAAIC,mBAAc,CACjD,iCAAiC,CAClC,CAAC;AACF,QAAa,YAAY,GAAG,IAAIA,mBAAc,CAC5C,4BAA4B,CAC7B,CAAC;AACF,QAAa,eAAe,GAAG,IAAIA,mBAAc,CAC/C,+BAA+B,CAChC;;;;;;;;;;;ACVD;QAUE,uBACU,aAA4B,EAC5BR,QAAiB;YADjB,kBAAa,GAAb,aAAa,CAAe;YAC5B,UAAK,GAALA,QAAK,CAAY;YAJnB,wBAAmB,GAAwB,IAAI,CAAC;SAKpD;QAEJ,6BAAK,GAAL;YACE,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE;gBAC7B,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,aAAa;qBAC1C,SAAS,EAAE;qBACX,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aAC1B;SACF;QAED,mCAAW,GAAX;YACE,IAAI,IAAI,CAAC,mBAAmB,EAAE;gBAC5B,IAAI,CAAC,mBAAmB,CAAC,WAAW,EAAE,CAAC;gBACvC,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;aACjC;SACF;QArBU,aAAa;YADzBN,eAAU,EAAE;+CAKc,aAAa;gBACrBY,WAAK;WALX,aAAa,CAsBzB;QAAD,oBAAC;KAtBD;;;;;;;;;;;;;;ACPA,QAWa,iBAAiB,GAAG,oBAAoB,CAAC;AAGtD;QACE,2BACU,OAAsB,EAC9B,MAAqB,EACrBN,QAAiB,EACK,WAAkB,EAC5B,eAAgC,EAChC,kBAAsC;YAL1C,YAAO,GAAP,OAAO,CAAe;YAO9B,MAAM,CAAC,KAAK,EAAE,CAAC;YAEf,WAAW,CAAC,OAAO,CAAC,UAAA,oBAAoB;gBACtC,OAAA,OAAO,CAAC,UAAU,CAAC,oBAAoB,CAAC;aAAA,CACzC,CAAC;YAEFA,QAAK,CAAC,QAAQ,CAAC,EAAE,IAAI,EAAE,iBAAiB,EAAE,CAAC,CAAC;SAC7C;QAED,sCAAU,GAAV,UAAW,oBAAyB;YAClC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,oBAAoB,CAAC,CAAC;SAC/C;QApBU,iBAAiB;YAD7BS,aAAQ,CAAC,EAAE,CAAC;YAMRC,aAAAf,WAAM,CAAC,YAAY,CAAC,CAAA;YACpBe,aAAAC,aAAQ,EAAE,CAAA;YACVD,aAAAC,aAAQ,EAAE,CAAA;+CALM,aAAa;gBACtB,aAAa;gBACdL,WAAK,SAEiBM,qBAAe;gBACZC,wBAAkB;WAPzC,iBAAiB,CAqB7B;QAAD,wBAAC;KArBD;;;;;;;;;;;;;;ACdA;QAOE,8BACE,IAAuB,EACE,kBAA2B,EACxC,eAAgC,EAChC,kBAAsC;YAElD,kBAAkB,CAAC,OAAO,CAAC,UAAA,KAAK;gBAC9B,OAAA,KAAK,CAAC,OAAO,CAAC,UAAA,oBAAoB;oBAChC,OAAA,IAAI,CAAC,UAAU,CAAC,oBAAoB,CAAC;iBAAA,CACtC;aAAA,CACF,CAAC;SACH;QAZU,oBAAoB;YADhCJ,aAAQ,CAAC,EAAE,CAAC;YAIRC,aAAAf,WAAM,CAAC,eAAe,CAAC,CAAA;YACvBe,aAAAC,aAAQ,EAAE,CAAA;YACVD,aAAAC,aAAQ,EAAE,CAAA;+CAHL,iBAAiB,SAEMC,qBAAe;gBACZC,wBAAkB;WALzC,oBAAoB,CAahC;QAAD,2BAAC;KAbD;;;;;;;;ACNA;QASA;SAoCC;QAnCQ,wBAAU,GAAjB,UACE,cAA2B;YAE3B,OAAO;gBACL,QAAQ,EAAE,oBAAoB;gBAC9B,SAAS,EAAE;oBACT,cAAc;oBACd;wBACE,OAAO,EAAE,eAAe;wBACxB,KAAK,EAAE,IAAI;wBACX,IAAI,EAAE,cAAc;wBACpB,UAAU,EAAE,qBAAqB;qBAClC;iBACF;aACF,CAAC;SACH;QAEM,qBAAO,GAAd,UACE,WAAwB;YAExB,OAAO;gBACL,QAAQ,EAAE,iBAAiB;gBAC3B,SAAS,EAAE;oBACT,aAAa;oBACb,aAAa;oBACb,OAAO;oBACP,WAAW;oBACX;wBACE,OAAO,EAAE,YAAY;wBACrB,IAAI,EAAE,WAAW;wBACjB,UAAU,EAAE,qBAAqB;qBAClC;iBACF;aACF,CAAC;SACH;QAnCU,aAAa;YADzBJ,aAAQ,CAAC,EAAE,CAAC;WACA,aAAa,CAoCzB;QAAD,oBAAC;KApCD,IAoCC;aAEe,qBAAqB;QAAC,mBAAmB;aAAnB,UAAmB,EAAnB,qBAAmB,EAAnB,IAAmB;YAAnB,8BAAmB;;QACvD,OAAO,SAAS,CAAC;IACnB,CAAC;;ICjDD;;;;OAIG;;ICJH;;OAEG;;;;;;;;;;;;;;;;;;;;;;;;;"}